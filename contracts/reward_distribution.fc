;; RewardDistribution Contract
;; Distributes rewards in proportion to the contribution

#include "stdlib.fc";

;; Storage structure:
;; operator_address - address of the PoolOperator
;; registry_address - address of the ParticipantRegistry
;; total_rewards_received - lifetime total rewards received
;; total_rewards_distributed - lifetime total rewards distributed
;; pending_rewards - current pending rewards pool
;; distribution_round - current distribution round number
;; last_distribution_time - timestamp of last distribution
;; min_distribution_amount - minimum amount to trigger distribution

const int MIN_DISTRIBUTION_AMOUNT = 1000000000; ;; 1 TON (in nanotons)
const int UPTIME_THRESHOLD_HIGH = 9500; ;; 95% uptime threshold for bonus
const int UPTIME_THRESHOLD_MID = 8000;  ;; 80% uptime threshold for minor penalty
const int STABILITY_BONUS_RATE = 1000;  ;; 10% bonus (basis points)
const int MINOR_PENALTY_RATE = 500;     ;; 5% penalty (basis points)
const int MAJOR_PENALTY_RATE = 2000;    ;; 20% penalty (basis points)
const int OUTAGE_PENALTY_RATE = 1000;   ;; 10% penalty for frequent outages (basis points)
const int OUTAGE_THRESHOLD = 3;         ;; 3+ outages = frequent
const int BASIS_POINTS = 10000;         ;; 100% = 10000 basis points

;; Error codes
const int ERROR_UNAUTHORIZED = 401;
const int ERROR_INSUFFICIENT_REWARDS = 410;
const int ERROR_INVALID_AMOUNT = 411;
const int ERROR_DISTRIBUTION_FAILED = 412;

;; Operation codes
const int OP_INITIALIZE = 1;
const int OP_RECEIVE_REWARD = 7;
const int OP_DISTRIBUTE_REWARDS = 20;
const int OP_MANUAL_DISTRIBUTE = 21;
const int OP_GET_PARTICIPANT_DATA = 22;

;; Storage management
(slice, slice, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),  ;; operator_address
        ds~load_msg_addr(),  ;; registry_address
        ds~load_coins(),     ;; total_rewards_received
        ds~load_coins(),     ;; total_rewards_distributed
        ds~load_coins(),     ;; pending_rewards
        ds~load_uint(32),    ;; distribution_round
        ds~load_uint(32)     ;; last_distribution_time
    );
}

() save_data(slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) impure inline {
    set_data(
        begin_cell()
            .store_slice(operator_address)
            .store_slice(registry_address)
            .store_coins(total_rewards_received)
            .store_coins(total_rewards_distributed)
            .store_coins(pending_rewards)
            .store_uint(distribution_round, 32)
            .store_uint(last_distribution_time, 32)
            .end_cell()
    );
}

;; Helper functions
() require_operator(slice sender, slice operator) impure inline {
    throw_unless(ERROR_UNAUTHORIZED, equal_slices(sender, operator));
}

;; Send message helper
() send_message(slice to_address, int amount, int mode, cell body) impure inline {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(body)
        .end_cell();
    send_raw_message(msg, mode);
}

;; Send simple transfer
() send_transfer(slice to_address, int amount) impure inline {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 1);
}

;; Calculate bonus/penalty based on uptime and outages
int calculate_modifier(int uptime, int outages) inline {
    int modifier = BASIS_POINTS; ;; Start at 100%

    ;; Apply uptime-based bonus or penalty
    if (uptime >= UPTIME_THRESHOLD_HIGH) {
        modifier += STABILITY_BONUS_RATE; ;; +10% bonus
    } elseif (uptime >= UPTIME_THRESHOLD_MID) {
        modifier -= MINOR_PENALTY_RATE; ;; -5% penalty
    } else {
        modifier -= MAJOR_PENALTY_RATE; ;; -20% penalty
    }

    ;; Apply outage penalty
    if (outages >= OUTAGE_THRESHOLD) {
        modifier -= OUTAGE_PENALTY_RATE; ;; -10% additional penalty
    }

    ;; Ensure modifier is non-negative
    if (modifier < 0) {
        modifier = 0;
    }

    return modifier;
}

;; Request participant data from registry
() request_participant_data(slice registry_address, slice participant_addr, int query_id) impure inline {
    cell body = begin_cell()
        .store_uint(OP_GET_PARTICIPANT_DATA, 32)
        .store_uint(query_id, 64)
        .store_slice(participant_addr)
        .end_cell();

    send_message(registry_address, 100000000, 1, body); ;; 0.1 TON for gas
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return (); ;; ignore empty messages
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    if (op == OP_INITIALIZE) {
        ;; Check if already initialized
        slice ds = get_data().begin_parse();
        if (~ ds.slice_empty?()) {
            throw(ERROR_UNAUTHORIZED);
        }

        slice registry_addr = in_msg_body~load_msg_addr();

        save_data(sender_address, registry_addr, 0, 0, 0, 0, now());
        return ();
    }

    ;; Load data for all other operations
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();

    if (op == OP_RECEIVE_REWARD) {
        ;; Only accept from operator
        require_operator(sender_address, operator_address);

        int reward_amount = in_msg_body~load_coins();
        int commission_rate = in_msg_body~load_uint(16);

        ;; Calculate operator commission
        int operator_commission = (reward_amount * commission_rate) / BASIS_POINTS;
        int net_reward = reward_amount - operator_commission;

        ;; Update totals
        total_rewards_received += reward_amount;
        pending_rewards += net_reward;

        save_data(operator_address, registry_address, total_rewards_received, total_rewards_distributed, pending_rewards, distribution_round, last_distribution_time);

        ;; Send commission to operator
        if (operator_commission > 0) {
            send_transfer(operator_address, operator_commission);
        }

        ;; Auto-distribute if threshold met
        if (pending_rewards >= MIN_DISTRIBUTION_AMOUNT) {
            ;; Trigger distribution in next message
            ;; (simplified - in production would batch this)
        }

        return ();
    }

    if (op == OP_MANUAL_DISTRIBUTE) {
        ;; Only operator can trigger manual distribution
        require_operator(sender_address, operator_address);

        throw_unless(ERROR_INSUFFICIENT_REWARDS, pending_rewards > 0);

        ;; In a real implementation, this would:
        ;; 1. Query registry for all participants and contributions
        ;; 2. Calculate each participant's share
        ;; 3. Apply bonuses/penalties
        ;; 4. Send payments

        ;; For this implementation, we'll use a simplified approach
        ;; where the operator provides participant list in subsequent messages

        distribution_round += 1;
        last_distribution_time = now();

        save_data(operator_address, registry_address, total_rewards_received, total_rewards_distributed, pending_rewards, distribution_round, last_distribution_time);
        return ();
    }

    if (op == OP_DISTRIBUTE_REWARDS) {
        ;; Only operator can execute distribution
        require_operator(sender_address, operator_address);

        ;; Parse distribution data
        slice participant_addr = in_msg_body~load_msg_addr();
        int contribution = in_msg_body~load_uint(64);
        int total_contribution = in_msg_body~load_uint(64);
        int uptime = in_msg_body~load_uint(32);
        int outages = in_msg_body~load_uint(16);

        throw_unless(ERROR_INSUFFICIENT_REWARDS, pending_rewards > 0);
        throw_unless(ERROR_INVALID_AMOUNT, total_contribution > 0);

        ;; Calculate base reward share
        int base_reward = (pending_rewards * contribution) / total_contribution;

        ;; Apply bonus/penalty modifier
        int modifier = calculate_modifier(uptime, outages);
        int final_reward = (base_reward * modifier) / BASIS_POINTS;

        ;; Ensure we don't distribute more than available
        if (final_reward > pending_rewards) {
            final_reward = pending_rewards;
        }

        ;; Update state
        pending_rewards -= final_reward;
        total_rewards_distributed += final_reward;

        save_data(operator_address, registry_address, total_rewards_received, total_rewards_distributed, pending_rewards, distribution_round, last_distribution_time);

        ;; Send reward to participant
        if (final_reward > 0) {
            send_transfer(participant_addr, final_reward);
        }

        return ();
    }

    throw(0xffff); ;; unknown operation
}

;; Get methods
int get_total_rewards_received() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return total_rewards_received;
}

int get_total_rewards_distributed() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return total_rewards_distributed;
}

int get_pending_rewards() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return pending_rewards;
}

int get_distribution_round() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return distribution_round;
}

int get_last_distribution_time() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return last_distribution_time;
}

slice get_operator_address() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return operator_address;
}

slice get_registry_address() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return registry_address;
}

(int, int, int, int, int) get_distribution_stats() method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();
    return (total_rewards_received, total_rewards_distributed, pending_rewards, distribution_round, last_distribution_time);
}

;; Calculate what a participant would receive based on contribution
int calculate_participant_reward(int contribution, int total_contribution, int uptime, int outages) method_id {
    (slice operator_address, slice registry_address, int total_rewards_received, int total_rewards_distributed, int pending_rewards, int distribution_round, int last_distribution_time) = load_data();

    if ((pending_rewards == 0) | (total_contribution == 0)) {
        return 0;
    }

    ;; Calculate base reward share
    int base_reward = (pending_rewards * contribution) / total_contribution;

    ;; Apply bonus/penalty modifier
    int modifier = calculate_modifier(uptime, outages);
    int final_reward = (base_reward * modifier) / BASIS_POINTS;

    return final_reward;
}
