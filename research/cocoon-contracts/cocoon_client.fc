#include "imports/stdlib.fc";
#include "utils.fc";
#include "opcodes.fc";

(slice, slice, int, int, int, int, int, int, int, cell) load_data() inline {
  return unpack_cocoon_client_data(get_data().begin_parse());
}

() save_data(slice owner_address, slice proxy_address, int proxy_public_key, int state, int balance, int stake, int tokens_used, int unlock_ts, int secret_hash, cell params) impure inline {
  set_data(pack_cocoon_client_data(owner_address, proxy_address, proxy_public_key, state, balance, stake, tokens_used, unlock_ts, secret_hash, params));
}

() forward_message_to_proxy(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                            int value, int mode, cell payload?) impure {
  builder state_cell = begin_cell()
    .store_uint(state, 2)
    .store_coins(balance)
    .store_coins(stake)
    .store_uint(tokens_used, 64)
    .store_uint(secret_hash, 256);

  builder msg = create_msg(BOUNCEABLE, proxy_address, value)
    .store_uint(op::client_proxy_request, 32)
    .store_uint(query_id, 64)
    .store_slice(owner_address)
    .store_ref(state_cell.end_cell())
    .store_maybe_ref(payload?);
  send_raw_message(msg.end_cell(), mode);
}


() forward_balance(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                        int top_up_amount, slice send_excesses_to) impure inline {
  builder msg = begin_cell()
    .store_uint(op::client_proxy_top_up, 32)
    .store_coins(top_up_amount)
    .store_slice(send_excesses_to);
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash,
                           0, SEND_MODE_CARRY_ALL_BALANCE, msg.end_cell());
}

() forward_register(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                    int nonce, slice send_excesses_to) impure inline {
  builder msg = begin_cell()
    .store_uint(op::client_proxy_register, 32)
    .store_uint(nonce, 64);
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash,
                           1, SEND_MODE_PAY_FEES_SEPARETELY, msg.end_cell());
  forward_excesses(send_excesses_to, query_id);
}

() forward_info(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                slice send_excesses_to) impure {
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash,
                           1, SEND_MODE_PAY_FEES_SEPARETELY, null());
  forward_excesses(send_excesses_to, query_id);
}

() forward_refund_granted(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                          int to_refund, slice send_excesses_to) impure {
  builder msg = begin_cell()
    .store_uint(op::client_proxy_refund_granted, 32)
    .store_coins(to_refund)
    .store_slice(send_excesses_to);
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash,
                           0, SEND_MODE_CARRY_ALL_BALANCE, msg.end_cell());
}

() forward_refund_force(slice proxy_address, int query_id, slice owner_address, int state, int balance, int stake, int tokens_used, int secret_hash,
                          int to_refund, slice send_excesses_to) impure {
  builder msg = begin_cell()
    .store_uint(op::client_proxy_refund_force, 32)
    .store_coins(to_refund)
    .store_slice(send_excesses_to);
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash,
                           0, SEND_MODE_CARRY_ALL_BALANCE, msg.end_cell());
}

(int, int) update_balance(int tokens_used, int balance, int new_tokens_used, cell params) {
  if (new_tokens_used <= tokens_used) {
    return (tokens_used, balance);
  }

  (int params_version, int unique_id, int is_test, int price_per_token,
   int worker_fee_per_token, int prompt_tokens_price_multiplier, int cached_tokens_price_multiplier, 
   int completion_tokens_price_multiplier, int reasoning_tokens_price_multiplier,
   int proxy_delay_before_close, int client_delay_before_close, int min_proxy_stake, int min_client_stake,
   cell proxy_sc_code, cell worker_sc_code, cell client_sc_code) = unpack_cocoon_params(params);

  int tokens = new_tokens_used - tokens_used;
  int balance_update = tokens * price_per_token;

  if (balance_update < balance) {
    return (new_tokens_used, balance - balance_update);
  } else {
    return (new_tokens_used, 0);
  }
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
      return ();
  }

  int to_leave_on_balance = max(my_balance - msg_value + my_storage_due(), COMMISSION_ESTIMATE + STORAGE_ESTIMATE);

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
      return ();
  }
  slice sender_address = cs~load_msg_addr();

  int op = in_msg_body~load_uint(32);
  if (op == op::do_not_process) {
    return ();
  }

  int query_id = in_msg_body~load_uint(64);

  (slice owner_address, slice proxy_address, int proxy_public_key, int state, int balance, int stake,
   int tokens_used, int unlock_ts, int secret_hash, cell params) = load_data();

  if (op == op::ext_client_top_up) {

    int top_up_amount = in_msg_body~load_coins();
    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, top_up_amount + COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, top_up_amount + COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);

    balance += top_up_amount;

    raw_reserve(to_leave_on_balance, 0);

    forward_balance(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, top_up_amount, send_excesses_to);

  } elseif (op == op::owner_client_change_secret_hash_and_top_up) {

    int top_up_amount = in_msg_body~load_coins();
    int new_secret_hash = in_msg_body~load_uint(256);
    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, top_up_amount + COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, top_up_amount + COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_message_from_owner, equal_slices_bits(sender_address, owner_address));

    balance += top_up_amount;
    secret_hash = new_secret_hash;

    raw_reserve(to_leave_on_balance, 0);

    forward_balance(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, top_up_amount, send_excesses_to);

  } elseif (op == op::owner_client_register) {

    int nonce = in_msg_body~load_uint(64);
    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_message_from_owner, equal_slices_bits(sender_address, owner_address));

    raw_reserve(to_leave_on_balance, 0);

    forward_register(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, nonce, send_excesses_to);

  } elseif (op == op::owner_client_change_secret_hash) {

    secret_hash = in_msg_body~load_uint(256);
    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_message_from_owner, equal_slices_bits(sender_address, owner_address));

    raw_reserve(to_leave_on_balance, 0);

    forward_info(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, send_excesses_to);

  } elseif (op == op::owner_client_increase_stake) {

    int new_stake = in_msg_body~load_coins();
    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_message_from_owner, equal_slices_bits(sender_address, owner_address));
    throw_unless(error::low_msg_value, new_stake > stake);

    stake = new_stake;
    raw_reserve(to_leave_on_balance, 0);

    forward_info(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, send_excesses_to);
  
  } elseif (op == op::owner_client_withdraw) {

    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_unless(error::closed, state == client_state_normal);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_owner, equal_slices_bits(sender_address, owner_address));
    throw_unless(error::low_smc_balance, balance > stake);

    int to_refund = balance - stake;
    balance = stake;
    raw_reserve(to_leave_on_balance, 0);

    forward_refund_granted(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, to_refund, send_excesses_to);

  } elseif (op == op::owner_client_request_refund) {

    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::expected_owner, equal_slices_bits(sender_address, owner_address));

    if (state == client_state_normal) {

      (int params_version, int unique_id, int is_test, int price_per_token,
       int worker_fee_per_token, int prompt_tokens_price_multiplier, int cached_tokens_price_multiplier, 
       int completion_tokens_price_multiplier, int reasoning_tokens_price_multiplier,
       int proxy_delay_before_close, int client_delay_before_close, int min_proxy_stake, int min_client_stake,
       cell proxy_sc_code, cell worker_sc_code, cell client_sc_code) = unpack_cocoon_params(params);

      state = client_state_closing;
      unlock_ts = now() + client_delay_before_close;

      raw_reserve(to_leave_on_balance, 0);

      if (balance > stake) {

        int to_refund = balance - stake;
        balance = stake;
    
        forward_refund_granted(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, to_refund, send_excesses_to);

      } else {
      
        forward_info(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, send_excesses_to);

      }

    } else {

      throw_unless(error::not_unlocked_yet, unlock_ts < now());

      state = client_state_closed;
      int to_refund = balance;
      balance = 0;

      raw_reserve(to_leave_on_balance, 0);

      forward_refund_force(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, to_refund, send_excesses_to);

    }

  } elseif (op == op::ext_client_charge_signed) {

    [slice payload, slice send_excesses_to] = signed_message_unpack_and_check_signature(in_msg_body, op, query_id, proxy_public_key);
    int new_tokens_used = payload~load_uint(64);
    slice expected_my_address = payload~load_msg_addr();
    payload.end_parse();

    throw_if(error::closed, state == client_state_closed);
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::old_message, tokens_used < new_tokens_used);
    throw_unless(error::expected_my_address, equal_slices_bits(expected_my_address, my_address()));

    (tokens_used, balance) = update_balance(tokens_used, balance, new_tokens_used, params);

    raw_reserve(to_leave_on_balance, 0);

    forward_info(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, send_excesses_to);

  } elseif (op == op::ext_client_grant_refund_signed) {

    [slice payload, slice send_excesses_to] = signed_message_unpack_and_check_signature(in_msg_body, op, query_id, proxy_public_key);
    int new_tokens_used = payload~load_uint(64);
    slice expected_my_address = payload~load_msg_addr();
    payload.end_parse();

    throw_if(error::closed, (state == client_state_closed) & (balance == 0));
    throw_unless(error::low_msg_value, COMMISSION_ESTIMATE <= msg_value);
    throw_unless(error::low_smc_balance, COMMISSION_ESTIMATE + to_leave_on_balance <= my_balance);
    throw_unless(error::old_message, tokens_used <= new_tokens_used);
    throw_unless(error::expected_my_address, equal_slices_bits(expected_my_address, my_address()));

    (tokens_used, balance) = update_balance(tokens_used, balance, new_tokens_used, params);

    state = client_state_closed;
    unlock_ts = 0;
    int to_refund = balance;
    balance = 0;

    raw_reserve(STORAGE_ESTIMATE, 0);

    forward_refund_granted(proxy_address, query_id, owner_address, state, balance, stake, tokens_used, secret_hash, to_refund, send_excesses_to);

  } else {

    throw (error::unknown_op);

  }

  save_data(owner_address, proxy_address, proxy_public_key, state, balance, stake, tokens_used, unlock_ts, secret_hash, params);

  return ();
}

(slice, slice, int, int, int, int, int, int, int) get_cocoon_client_data() method_id {
  (slice owner_address, slice proxy_address, int proxy_public_key, int state, int balance, int stake, int tokens_used, int unlock_ts, int secret_hash, cell params) = load_data();
  return (owner_address, proxy_address, proxy_public_key, state, balance, stake, tokens_used, unlock_ts, secret_hash);
}
