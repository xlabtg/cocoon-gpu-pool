#include "imports/stdlib.fc";
#include "opcodes.fc";
#include "utils.fc";


() recv_external(slice in_msg) impure {
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
  throw_if(1030, valid_until <= now());
  var ds = get_data().begin_parse();
  var (stored_seqno, stored_subwallet, public_key, status, owner_address) =
      (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256), ds~load_uint(32), ds~load_msg_addr());
  ds.end_parse();
  throw_if(1031, status & 1);
  throw_unless(1032, msg_seqno == stored_seqno);
  throw_unless(1033, subwallet_id == stored_subwallet);
  throw_unless(1034, check_signature(slice_hash(in_msg), signature, public_key));
  throw_if(1035, my_balance() < 2 * ONE_TON);
  accept_message();
  cs~touch();
  while (cs.slice_refs()) {
    var mode = cs~load_uint(8);
    send_raw_message(cs~load_ref(), mode);
  }
  set_data(begin_cell()
    .store_uint(stored_seqno + 1, 32)
    .store_uint(stored_subwallet, 32)
    .store_uint(public_key, 256)
    .store_uint(status, 32)
    .store_slice(owner_address)
    .end_cell());
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
      return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
      return ();
  }
  slice sender_address = cs~load_msg_addr();

  int op = in_msg_body~load_uint(32);
  if ((op == op::excesses) | (op == op::payout) | (op == op::do_not_process)) {
    return ();
  }

  var ds = get_data().begin_parse();
  var (stored_seqno, stored_subwallet, public_key, status, owner_address) =
      (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256), ds~load_uint(32), ds~load_msg_addr());
  ds.end_parse();

  throw_unless(1040, equal_slices_bits(sender_address, owner_address));


  if (op == op::owner_wallet_send_message) {
    int query_id = in_msg_body~load_uint(64);
    int mode = in_msg_body~load_uint(8);
    cell body = in_msg_body~load_ref();
    send_raw_message(body, mode);
    return ();
  }


  throw_unless(1041, op == 0);
  int action = in_msg_body~load_uint(8);
  in_msg_body.end_parse();

  int is_withdraw = action == "w"u;
  int is_block = action == "b"u;
  int is_unblock = action == "u"u;

  throw_unless(1041, is_withdraw | is_block | is_unblock);

  if (is_withdraw) {

    raw_reserve(ONE_TON / 100, 2); ;; so that the contract stays alive and can correctly reject all top-ups

    builder msg = create_msg(BOUNCEABLE, sender_address, 0)
      .store_uint(0, 32) ;; op
      .store_uint("w"u, 8);

    send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_BALANCE);
    return ();

  } elseif (is_block) {
    set_data(begin_cell()
      .store_uint(stored_seqno, 32)
      .store_uint(stored_subwallet, 32)
      .store_uint(public_key, 256)
      .store_uint(status | 1, 32)
      .store_slice(owner_address)
      .end_cell());
    return ();
  } elseif (is_unblock) {
    set_data(begin_cell()
      .store_uint(stored_seqno, 32)
      .store_uint(stored_subwallet, 32)
      .store_uint(public_key, 256)
      .store_uint(status & 0xfffffffe, 32)
      .store_slice(owner_address)
      .end_cell());
    return ();
  }
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

int get_public_key() method_id {
  var cs = get_data().begin_parse();
  cs~load_uint(64);
  return cs.preload_uint(256);
}

slice get_owner_address() method_id {
  var cs = get_data().begin_parse();
  cs~skip_bits(64 + 32 + 256);
  var addr = cs~load_msg_addr();
  return addr;
}
