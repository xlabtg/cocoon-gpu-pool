#include "imports/stdlib.fc";
#include "utils.fc";
#include "opcodes.fc";

(slice, slice, int, int, int, cell) load_data() inline {
  return unpack_cocoon_worker_data(get_data().begin_parse());
}

() save_data(slice owner_address, slice proxy_address, int proxy_public_key, int state, int tokens, cell params) impure inline {
  set_data(pack_cocoon_worker_data(owner_address, proxy_address, proxy_public_key, state, tokens, params));
}

() forward_message_to_proxy(slice proxy_address, int query_id, slice owner_address, int state, int tokens, int value, int mode, cell payload?) impure inline {
  builder msg = create_msg(BOUNCEABLE, proxy_address, value)
    .store_uint(op::worker_proxy_request, 32)
    .store_uint(query_id, 64)
    .store_slice(owner_address)
    .store_uint(state, 2)
    .store_uint(tokens, 64)
    .store_maybe_ref(payload?);
  send_raw_message(msg.end_cell(), mode);
}

() forward_payout_request(slice proxy_address, int query_id, slice owner_address, int state, int tokens, int worker_part, int proxy_part, slice send_excesses_to) impure inline {
  builder payload = begin_cell()
    .store_uint(op::worker_proxy_payout_request, 32)
    .store_coins(worker_part)
    .store_coins(proxy_part)
    .store_slice(send_excesses_to);

  forward_message_to_proxy(proxy_address, query_id, owner_address, state, tokens, 0, SEND_MODE_CARRY_ALL_BALANCE, payload.end_cell());
}

() forward_register(slice proxy_address, int query_id, slice owner_address, int state, int tokens, slice send_excesses_to) impure inline {
  forward_message_to_proxy(proxy_address, query_id, owner_address, state, tokens, 1, SEND_MODE_PAY_FEES_SEPARETELY, null());
  forward_excesses(send_excesses_to, query_id);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
      return ();
  }

  int to_leave_on_balance = max(my_balance - msg_value + my_storage_due(), COMMISSION_ESTIMATE + STORAGE_ESTIMATE);

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
      return ();
  }
  slice sender_address = cs~load_msg_addr();

  int op = in_msg_body~load_uint(32);
  if (op == op::do_not_process) {
    return ();
  }
  int query_id = in_msg_body~load_uint(64);
  (slice owner_address, slice proxy_address, int proxy_public_key, int state, int tokens, cell params) = load_data();

  throw_if(error::closed, state == worker_state_closed);

  if ((op == op::ext_worker_payout_request_signed) | (op == op::ext_worker_last_payout_request_signed)) {

    [slice payload, slice send_excesses_to] = signed_message_unpack_and_check_signature(in_msg_body, op, query_id, proxy_public_key);
    int new_tokens = payload~load_uint(64);
    slice expected_my_address = payload~load_msg_addr();
    payload.end_parse();

    throw_unless(error::low_msg_value, msg_value > COMMISSION_ESTIMATE);
    throw_unless(error::expected_my_address, equal_slices_bits(expected_my_address, my_address()));

    (int params_version, int unique_id, int is_test, int price_per_token,
     int worker_fee_per_token, int prompt_tokens_price_multiplier, int cached_tokens_price_multiplier, 
     int completion_tokens_price_multiplier, int reasoning_tokens_price_multiplier,
     int proxy_delay_before_close, int client_delay_before_close, int min_proxy_stake, int min_client_stake,
     cell proxy_sc_code, cell worker_sc_code, cell client_sc_code) = unpack_cocoon_params(params);

    int tokens_delta = new_tokens - tokens;
    int worker_part = tokens_delta * worker_fee_per_token;
    int proxy_part = tokens_delta * (price_per_token - worker_fee_per_token);

    if (op == op::ext_worker_payout_request_signed) {

      throw_unless(error::old_message, tokens < new_tokens);

      raw_reserve(to_leave_on_balance, 0);
      forward_payout_request(proxy_address, query_id, owner_address, state, new_tokens, worker_part, proxy_part, send_excesses_to);

    } else {

      throw_unless(error::old_message, tokens <= new_tokens);

      state = worker_state_closed;

      raw_reserve(STORAGE_ESTIMATE, 0);
      forward_payout_request(proxy_address, query_id, owner_address, state, new_tokens, worker_part, proxy_part, send_excesses_to);

    }

    save_data(owner_address, proxy_address, proxy_public_key, state, new_tokens, params);

    return ();

  } elseif (op == op::owner_worker_register) {

    throw_unless(error::low_msg_value, msg_value > COMMISSION_ESTIMATE);
    throw_unless(error::expected_message_from_owner, equal_slices_bits(sender_address, owner_address));

    slice send_excesses_to = in_msg_body~load_msg_addr();
    in_msg_body.end_parse();

    raw_reserve(to_leave_on_balance, 0);

    forward_register(proxy_address, query_id, owner_address, state, tokens, send_excesses_to);

    return ();

  } else {

    throw (error::unknown_op);

  }
}

(slice, slice, int, int, int) get_cocoon_worker_data() method_id {
  (slice owner_address, slice proxy_address, int proxy_public_key, int state, int tokens, cell params) = load_data();
  return (owner_address, proxy_address, proxy_public_key, state, tokens);
}
